'use strict';

exports.__esModule = true;
exports.run = run;
exports.done = done;
exports.startCheck = startCheck;
exports.addCheck = addCheck;
exports.removeCheck = removeCheck;
exports.startCheckAndRun = startCheckAndRun;
exports.runPending = runPending;

var _util = require('./util');

function run() {
    if (this.tasks.list.length) {
        if (this.tasks.running < this.concurrency) {
            this.tasks.list.shift()(done.bind(this));
            this.tasks.running++;
        }
    } else {
        if (this.tasks.completed === this.tasks.total) {
            this.duration.end = Date.now();
            this.duration.total = this.duration.end - this.duration.start;
            this.__working = false;
            if ((0, _util.isFunction)(this.onEnd)) {
                var completed = this.tasks.completed,
                    duration = this.duration;

                this.onEnd({ completed: completed, duration: duration });
            }
        }
    }
}

function done() {
    this.tasks.completed++;
    this.tasks.running--;
    this.duration.total = Date.now() - this.duration.start;
    if ((0, _util.isFunction)(this.onDone)) {
        this.onDone(this.tasks);
    }
    run.call(this);
}

function startCheck() {
    if (!this.__working) {
        this.duration.start = Date.now();
        this.__working = true;
        if ((0, _util.isFunction)(this.onStart)) {
            var duration = this.duration;

            this.onStart({ duration: duration });
        }
    }
}

function addCheck() {
    if ((0, _util.isFunction)(this.onAdd)) {
        var tasks = this.tasks;

        this.onAdd({ tasks: tasks });
    }
}

function removeCheck() {
    if ((0, _util.isFunction)(this.onRemove)) {
        var tasks = this.tasks;

        this.onRemove({ tasks: tasks });
    }
}

function startCheckAndRun() {
    startCheck.call(this);
    run.call(this);
}

function runPending() {
    if (this.tasks.running < this.concurrency) {
        var concurrency = this.concurrency === Infinity ? this.tasks.list.length : this.concurrency;
        for (var i = this.tasks.running; i < concurrency; i++) {
            run.call(this);
        }
    }
}